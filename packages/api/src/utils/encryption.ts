import crypto from 'node:crypto';
import { SECRET_1, SECRET_2 } from '../config';

const ALGORITHM = 'aes-256-gcm';
const IV_LENGTH = 12;
const SECRET_KEY_LENGTH = 32;
const AUTH_TAG_LENGTH = 16;

// Ensure key is 32 bytes. using scrypt to derive a key from the secret
// salt is empty or fixed because we want deterministic key from the same secret env
const SECRET_KEY = crypto.scryptSync(SECRET_1, SECRET_2, SECRET_KEY_LENGTH);

/**
 * Encrypts data using AES-256-GCM
 * @param {Buffer} data - The content to encrypt
 * @returns {Buffer} - Combined IV + AuthTag + Ciphertext
 */
export function encrypt(data: Buffer): Buffer {
    // 1. Prepare IV
    const iv = crypto.randomBytes(IV_LENGTH); // GCM standard IV size

    // 2. Create Cipher
    const cipher = crypto.createCipheriv(ALGORITHM, SECRET_KEY, iv);

    // 3. Encrypt
    const encrypted = Buffer.concat([cipher.update(data), cipher.final()]);

    // 4. Get Authentication Tag (16 bytes)
    const authTag = cipher.getAuthTag();

    // 5. Combine everything into one Buffer for easy storage
    return Buffer.concat([iv, authTag, encrypted]);
}

/**
 * Decrypts a Buffer generated by the encrypt function
 * @param {Buffer} encryptedBundle - The combined Buffer
 * @returns {Buffer} - The original raw data
 */
export function decrypt(encryptedBundle: Buffer): Buffer {
    // 1. Extract pieces (IV: 12 bytes, Tag: 16 bytes)
    const iv = encryptedBundle.subarray(0, IV_LENGTH);
    const authTag = encryptedBundle.subarray(IV_LENGTH, IV_LENGTH + AUTH_TAG_LENGTH);
    const ciphertext = encryptedBundle.subarray(IV_LENGTH + AUTH_TAG_LENGTH);

    // 2. Create Decipher
    const decipher = crypto.createDecipheriv(ALGORITHM, SECRET_KEY, iv);
    decipher.setAuthTag(authTag);

    // 3. Decrypt and return
    return Buffer.concat([decipher.update(ciphertext), decipher.final()]);
}
